{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red154\green154\blue154;\red255\green255\blue254;\red0\green0\blue0;
\red0\green0\blue255;\red144\green1\blue18;\red19\green120\blue72;\red252\green76\blue165;}
{\*\expandedcolortbl;;\cssrgb\c66667\c66667\c66667;\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c0\c0;
\cssrgb\c0\c0\c100000;\cssrgb\c63922\c8235\c8235;\cssrgb\c3529\c53333\c35294;\cssrgb\c100000\c41176\c70588;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 //================================================\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //Complete Koans and Submit count as 5pt HW in total\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //There are 15 tests and 3 output prints from this example\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //Each worth 0.25 pt in HW\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //Submission is 0.5 pt in HW\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //Correct output:\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //T1...Test Success\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //...\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //T15...Test Success\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //The top of the current stack is 3.000000\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //The top of the current stack is 27.000000\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //The top of the current stack is 6.000000\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //================================================\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  AssertEquality inputTuple =\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3   \cf5 \strokec5 match\cf4 \strokec4  inputTuple \cf5 \strokec5 with\cf4 \cb1 \strokec4 \
\cb3   | (a,b) \cf5 \strokec5 when\cf4 \strokec4  a=b -> printfn \cf6 \strokec6 "Test Success"\cf4 \cb1 \strokec4 \
\cb3   | (a,b) \cf2 \strokec2 (*when a<>b*)\cf4 \strokec4  -> printfn \cf6 \strokec6 "Test Fail"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //==============================================\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //Build a stack based calculator\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //==============================================\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //==============================================\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Define types\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ==============================================\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //name a stack -- regular:\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //type Stacktest = float list\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //Comment out the regular def (line 16)\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //name a stack -- better:\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 type\cf4 \strokec4  Stack = StackContents \cf5 \strokec5 of\cf4 \strokec4  float list\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //### now test your code\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  testStack1=StackContents [\cf7 \strokec7 1.0\cf4 \strokec4 ;\cf7 \strokec7 2.0\cf4 \strokec4 ;\cf7 \strokec7 3.0\cf4 \strokec4 ]\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  (StackContents contents)=testStack1 \cf2 \strokec2 //get the content from a stack using pattern matching\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3 printf \cf6 \strokec6 "\cf8 \strokec8 \\n\\n\\n\cf6 \strokec6 T1..."\cf4 \cb1 \strokec4 \
\cb3 AssertEquality (contents, contents)\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 // ==============================================\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Stack primitives -- push pop\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ==============================================\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //Push a value on the stack -- regular\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //let push x aStack =   \cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3   \cf2 \strokec2 //let (StackContents contents) = aStack\cf4 \cb1 \strokec4 \
\cb3   \cf2 \strokec2 //let newContents = x::contents\cf4 \cb1 \strokec4 \
\cb3   \cf2 \strokec2 //StackContents newContents\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //list is immutable so you always add element to the head and return a new list\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //Comment out the regular def\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // Push a value on the stack -- better\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //(StackContents contents) is a Stack var being passed over as func input (aStack in the regular version).\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //The pattern matching line "let (...)=aStack" is condensed and happens at the input variable line\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  push x (StackContents contents) =   \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     StackContents (x::contents)\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //### now test your code\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  emptyStack = StackContents []\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  stackWith1test = push \cf7 \strokec7 1.0\cf4 \strokec4  emptyStack \cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  stackWith2test = push \cf7 \strokec7 2.0\cf4 \strokec4  stackWith1test\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3 printf \cf6 \strokec6 "T2..."\cf4 \cb1 \strokec4 \
\cb3 AssertEquality (stackWith2test, StackContents [\cf7 \strokec7 2.0\cf4 \strokec4 ;\cf7 \strokec7 1.0\cf4 \strokec4 ])\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //If you remember, in F#, we can pass over only 1 var and have a partial func as the return value\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //like giving y=5 in f(x,y)=x+y returns function: f(x,5)=x+5\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //push takes x and a stack as input variables. We can give x as input var only and have f (defined-x, stack) as return value\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  ONE = push \cf7 \strokec7 1.0\cf4 \strokec4  \cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  TWO = push \cf7 \strokec7 2.0\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  THREE = push \cf7 \strokec7 3.0\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  FOUR = push \cf7 \strokec7 4.0\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  FIVE = push \cf7 \strokec7 5.0\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  EMPTY = StackContents []\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //### now test your code\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  stackWith1 = ONE EMPTY \cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  stackWith2 = TWO stackWith1\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  stackWith3  = THREE stackWith2\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //You might also remember that those partially defined functions are very useful when building pipes to make your code very concise and easy to read:\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result123 = EMPTY |> ONE |> TWO |> THREE \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3 printf \cf6 \strokec6 "T3..."\cf4 \cb1 \strokec4 \
\cb3 AssertEquality (stackWith3, result123)\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //you can also do:\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result312 = EMPTY |> THREE |> ONE |> TWO\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3 printf \cf6 \strokec6 "T4..."\cf4 \cb1 \strokec4 \
\cb3 AssertEquality (result312,StackContents [\cf7 \strokec7 2.0\cf4 \strokec4 ;\cf7 \strokec7 1.0\cf4 \strokec4 ;\cf7 \strokec7 3.0\cf4 \strokec4 ])\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 // Pop a value from the stack and return it \cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // and the new stack as a tuple\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  pop (StackContents contents) = \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 match\cf4 \strokec4  contents \cf5 \strokec5 with\cf4 \strokec4  \cb1 \
\cb3     | top::rest -> \cb1 \
\cb3       \cf5 \strokec5 let\cf4 \strokec4  newStack = StackContents rest\cb1 \
\cb3       (top , newStack)\cb1 \
\cb3     |[] -> \cb1 \
\cb3         failwith \cf6 \strokec6 "Stack underflow"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //### now test your code\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  initialStack = EMPTY  |> ONE |> TWO \cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  popped1, poppedStack = pop initialStack\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  popped2, poppedStack2 = pop poppedStack\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3 printf \cf6 \strokec6 "T5..."\cf4 \cb1 \strokec4 \
\cb3 AssertEquality (initialStack,StackContents [\cf7 \strokec7 2.0\cf4 \strokec4 ;\cf7 \strokec7 1.0\cf4 \strokec4 ])\cb1 \
\cb3 printf \cf6 \strokec6 "T6..."\cf4 \cb1 \strokec4 \
\cb3 AssertEquality (poppedStack, StackContents [\cf7 \strokec7 1.0\cf4 \strokec4 ])\cb1 \
\cb3 printf \cf6 \strokec6 "T7..."\cf4 \cb1 \strokec4 \
\cb3 AssertEquality (popped2, \cf7 \strokec7 1.0\cf4 \strokec4 )\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 // ==============================================\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Operator core\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ==============================================\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //let us do add first:\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  ADDtest stack =\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3   \cf5 \strokec5 let\cf4 \strokec4  x,s = pop stack  \cf2 \strokec2 //pop the top of the stack\cf4 \cb1 \strokec4 \
\cb3   \cf5 \strokec5 let\cf4 \strokec4  y,s2 = pop s     \cf2 \strokec2 //pop the result stack\cf4 \cb1 \strokec4 \
\cb3   \cf5 \strokec5 let\cf4 \strokec4  resultAdd = x + y   \cf2 \strokec2 //do the math\cf4 \cb1 \strokec4 \
\cb3   push resultAdd s2       \cf2 \strokec2 //push back on the doubly-popped stack\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //###test your code\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  add12=ADDtest initialStack \cf2 \strokec2 //list is immutable, so the initialStack is always [2.0;1.0]\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3 printf \cf6 \strokec6 "T8..."\cf4 \cb1 \strokec4 \
\cb3 AssertEquality (add12, StackContents [\cf7 \strokec7 3.0\cf4 \strokec4 ])\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //Similarly, we can define MUL\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  MULtest stack = \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3   \cf5 \strokec5 let\cf4 \strokec4  x,s = pop stack \cf2 \strokec2 //pop the top of the stack\cf4 \cb1 \strokec4 \
\cb3   \cf5 \strokec5 let\cf4 \strokec4  y,s2 = pop s     \cf2 \strokec2 //pop the result stack\cf4 \cb1 \strokec4 \
\cb3   \cf5 \strokec5 let\cf4 \strokec4  resultMul = x * y    \cf2 \strokec2 //do the math \cf4 \cb1 \strokec4 \
\cb3   push resultMul s2      \cf2 \strokec2 //push back on the doubly-popped stack\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //###test your code\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  mul12=MULtest initialStack \cf2 \strokec2 //list is immutable, so the initialStack is always [2.0;1.0]\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3 printf \cf6 \strokec6 "T9..."\cf4 \cb1 \strokec4 \
\cb3 AssertEquality (mul12, StackContents [\cf7 \strokec7 2.0\cf4 \strokec4 ])\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //Now, you can see that ADD and MUL are super similar since they both use 2 numbers for calc\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //We can merge ADD and MUL together to make the code even more concise.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //Define a generic binary math operator:\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // pop the top two elements\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // do a binary operation on them\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // push the result \cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  binary mathFn stack = \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 let\cf4 \strokec4  y,stack\cf6 \strokec6 '\cf4 \strokec4  = pop stack    \cb1 \
\cb3     \cf5 \strokec5 let\cf4 \strokec4  x,stack\cf6 \strokec6 ''\cf4 \strokec4  = pop stack\cf6 \strokec6 '\cf4 \strokec4   \cb1 \
\cb3     \cf5 \strokec5 let\cf4 \strokec4  z = mathFn x y\cb1 \
\cb3     push z stack\cf6 \strokec6 ''\cf4 \strokec4       \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //If we want to do add using this generic binary math func:\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  genericBinaryMath12=binary (+) initialStack \cf2 \strokec2 //This is same to: let ADD aStack = binary (fun x y -> x + y) aStack\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //By using partical func, we have a new way of defining ADD and more:\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  ADD = binary (+) \cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  SUB = binary (-)\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  MUL = binary (*)\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  DIV = binary (/)\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //It is an amazingly concise and clear way of defining multiple similar functions sharing the same base func\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //Does this sounds like class inherantance to you? Yes, but in a more concise way!\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //###Now test your code:\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  div3by2 = EMPTY |> THREE|> TWO |> DIV\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  sub2from5 = EMPTY |> FIVE |> TWO |> SUB\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  sub2from5thenadd1 = EMPTY |> FIVE |> TWO |> SUB |> ONE |> ADD\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3 printf \cf6 \strokec6 "T10..."\cf4 \cb1 \strokec4 \
\cb3 AssertEquality(div3by2, StackContents [\cf7 \strokec7 1.5\cf4 \strokec4 ])\cb1 \
\cb3 printf \cf6 \strokec6 "T11..."\cf4 \cb1 \strokec4 \
\cb3 AssertEquality(sub2from5, StackContents [\cf7 \strokec7 3.0\cf4 \strokec4 ])\cb1 \
\cb3 printf \cf6 \strokec6 "T12..."\cf4 \cb1 \strokec4 \
\cb3 AssertEquality(sub2from5thenadd1, StackContents [\cf7 \strokec7 4.0\cf4 \strokec4 ])\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //Similar to the binary operators, we can define the generic unary operator for things like power **\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // pop the top element\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // do a unary operation on it\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // push the result \cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  unary f stack = \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3   \cf5 \strokec5 let\cf4 \strokec4  x,stack\cf6 \strokec6 '\cf4 \strokec4  = pop stack  \cb1 \
\cb3   push (f x) stack\cf6 \strokec6 '\cf4 \strokec4          \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //We can define negative number or square with the unary operator and the partial function\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  NEG = unary (\cf5 \strokec5 fun\cf4 \strokec4  x -> -x)\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  SQUARE = unary (\cf5 \strokec5 fun\cf4 \strokec4  x -> x * x)\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //###Now test your code:\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  neg3 = EMPTY  |> THREE|> NEG\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  square2 = EMPTY |> TWO |> SQUARE\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  squareneg3= EMPTY |> THREE|> NEG |> SQUARE\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3 printf \cf6 \strokec6 "T13..."\cf4 \cb1 \strokec4 \
\cb3 AssertEquality(neg3, StackContents [-\cf7 \strokec7 3.0\cf4 \strokec4 ])\cb1 \
\cb3 printf \cf6 \strokec6 "T14..."\cf4 \cb1 \strokec4 \
\cb3 AssertEquality(square2, StackContents [\cf7 \strokec7 4.0\cf4 \strokec4 ])\cb1 \
\cb3 printf \cf6 \strokec6 "T15..."\cf4 \cb1 \strokec4 \
\cb3 AssertEquality(squareneg3, StackContents [\cf7 \strokec7 9.0\cf4 \strokec4 ])\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 // ==============================================\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Other core \cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ==============================================\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 /// Pop and show the top value on the stack\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  SHOW stack = \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 let\cf4 \strokec4  x,_ = pop stack\cb1 \
\cb3     printfn \cf6 \strokec6 "The top of the current stack is %f"\cf4 \strokec4  x\cb1 \
\cb3     stack \cf2 \strokec2 // return the same stack\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 /// Drop the top value on the stack\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 (*let DROP stack = \cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2     let _,s = pop stack  //pop the top of the stack\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2     ___                    //return the rest\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 *)\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 /// Duplicate the top value on the stack\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  DUP stack = \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     \cf2 \strokec2 // get the top of the stack\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 let\cf4 \strokec4  x,_ = pop stack  \cb1 \
\cb3     \cf2 \strokec2 // push it onto the stack again\cf4 \cb1 \strokec4 \
\cb3     push x stack  \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 /// Swap the top two values\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  SWAP stack = \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 let\cf4 \strokec4  x,s = pop stack  \cb1 \
\cb3     \cf5 \strokec5 let\cf4 \strokec4  y,s\cf6 \strokec6 '\cf4 \strokec4  = pop s\cb1 \
\cb3     push y (push x s\cf6 \strokec6 '\cf4 \strokec4 ) \cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  CUBE = \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     DUP >> DUP >> MUL >> MUL\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  SUM_NUMBERS_UPTO = \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     DUP                     \cf2 \strokec2 // n  \cf4 \cb1 \strokec4 \
\cb3     >> ONE >> ADD           \cf2 \strokec2 // n+1\cf4 \cb1 \strokec4 \
\cb3     >> MUL                 \cf2 \strokec2 // n(n+1)\cf4 \cb1 \strokec4 \
\cb3     >> TWO >> DIV   \cf2 \strokec2 // n(n+1) / 2\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //Can you see how easy it is to build new functions from already defined functions? The code also looks very clearn and easy to read\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //###now test your code\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  myStack= EMPTY |> ONE |> TWO |> THREE\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  stackTop= myStack |> SHOW \cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  stackTopEleCubed = myStack |> CUBE |> SHOW\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  stackSum=myStack |> SUM_NUMBERS_UPTO |> SHOW\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 //Referenced F# for fun and profit\cf4 \cb1 \strokec4 \
\
}